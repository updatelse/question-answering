class MutanFusion(AbstractFusion):

    def __init__(self, opt, visual_embedding=True, question_embedding=True):   
        super(MutanFusion, self).__init__(opt
        self.visual_embedding = visual_embedding                                   """输入：问题特征向量q、图像特征向量v """
        self.question_embedding = question_embedding                               """功能：将q和v进行融合 """
        
            #-----将问题向量和视觉向量在融合前嵌入-----
        if self.visual_embedding:
            self.linear_v = nn.Linear(self.opt['dim_v'], self.opt['dim_hv'])
        else:
            print('Warning fusion.py: no visual embedding before fusion')       
                       
        if self.question_embedding:
            self.linear_q = nn.Linear(self.opt['dim_q'], self.opt['dim_hq'])
        else:
            print('Warning fusion.py: no question embedding before fusion')
        
        self.list_linear_hv = nn.ModuleList([           #图像特征线性变换
            nn.Linear(self.opt['dim_hv'], self.opt['dim_mm'])
            for i in range(self.opt['R'])]) 

        self.list_linear_hq = nn.ModuleList([           #问题特征线性变换
            nn.Linear(self.opt['dim_hq'], self.opt['dim_mm'])
            for i in range(self.opt['R'])])             #有秩R稀疏约束


    def forward(self, input_v, input_q): 
      #前向传播，进行模型的计算，两个参数input_v, input_q的维度都是2
      
        if input_v.dim() != input_q.dim() and input_v.dim() != 2:    # 判断视觉输入维度和问题维度是否不相等且不等于2
            raise ValueError
        batch_size = input_v.size(0)

        if self.visual_embedding:    #处理图像的嵌入
            x_v = F.dropout(input_v, p=self.opt['dropout_v'], training=self.training)
            x_v = self.linear_v(x_v) 
            if 'activation_v' in self.opt:
                    x_v = getattr(F, self.opt['activation_v'])(x_v)
        else:
            x_v = input_v

        if self.question_embedding:     #处理问题的嵌入
            x_q = F.dropout(input_q, p=self.opt['dropout_q'], training=self.training)
            x_q = self.linear_q(x_q)
            if 'activation_q' in self.opt:
                    x_q = getattr(F, self.opt['activation_q'])(x_q)
        else:
            x_q = input_q  
                                   秩R的约束，原文Z表示成R个Zr的总和，Z会投影到预测空间y上。
        x_mm = []
        for i in range(self.opt['R']):

            x_hv = F.dropout(x_v, p=self.opt['dropout_hv'], training=self.training)
            x_hv = self.list_linear_hv[i](x_hv)
            if 'activation_hv' in self.opt:
                x_hv = getattr(F, self.opt['activation_hv'])(x_hv)

            x_hq = F.dropout(x_q, p=self.opt['dropout_hq'], training=self.training)
            x_hq = self.list_linear_hq[i](x_hq)
            if 'activation_hq' in self.opt:
                x_hq = getattr(F, self.opt['activation_hq'])(x_hq)

            x_mm.append(torch.mul(x_hq, x_hv))     #q、v的维度相同，使用mul()对应位相乘进行融合，融合后大小不变

        x_mm = torch.stack(x_mm, dim=1)
        x_mm = x_mm.sum(1).view(batch_size, self.opt['dim_mm'])

        if 'activation_mm' in self.opt:
            x_mm = getattr(F, self.opt['activation_mm'])(x_mm)       # activation_mm = softmax，模型的输出output，来预测答案。

        return x_mm     #返回
